# AIå·¥ä½œæµç¼–æ’ç³»ç»Ÿ - é‡æ–°è®¾è®¡æ¶æ„

## 1. è®¾è®¡åŸåˆ™å’Œç›®æ ‡

### 1.1 è®¾è®¡åŸåˆ™
- **é«˜å†…èšä½è€¦åˆ** - é€šè¿‡é¢†åŸŸé©±åŠ¨è®¾è®¡å®ç°æ¸…æ™°çš„ä¸šåŠ¡è¾¹ç•Œ
- **äº‹ä»¶é©±åŠ¨** - é€šè¿‡äº‹ä»¶å®ç°ç³»ç»Ÿé—´çš„æ¾è€¦åˆé€šä¿¡
- **å“åº”å¼** - æ”¯æŒé«˜å¹¶å‘å’Œéé˜»å¡I/Oæ“ä½œ
- **å¯è§‚æµ‹æ€§** - å†…ç½®ç›‘æ§ã€é“¾è·¯è¿½è¸ªå’Œæ—¥å¿—
- **æ•…éšœå®¹å¿** - æ”¯æŒç†”æ–­ã€é‡è¯•å’Œé™çº§æœºåˆ¶

### 1.2 æ¶æ„ç›®æ ‡
- ğŸš€ **é«˜æ€§èƒ½** - æ”¯æŒä¸‡çº§å¹¶å‘ä»»åŠ¡æ‰§è¡Œ
- ğŸ”§ **é«˜å¯ç”¨** - 99.9%ç³»ç»Ÿå¯ç”¨æ€§
- ğŸ“ˆ **å¯æ‰©å±•** - æ°´å¹³æ‰©å±•æ”¯æŒ
- ğŸ›¡ï¸ **å®‰å…¨æ€§** - ç«¯åˆ°ç«¯å®‰å…¨ä¿éšœ
- ğŸ” **å¯è§‚æµ‹** - å…¨é“¾è·¯ç›‘æ§å’Œè¿½è¸ª

---

## 2. æ–°æ¶æ„è®¾è®¡

### 2.1 æ€»ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯ç•Œé¢å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æµç¨‹è®¾è®¡å™¨  â”‚  ç›‘æ§é¢æ¿   â”‚  Agentç®¡ç†   â”‚  ç³»ç»Ÿé…ç½®               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        APIç½‘å…³å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è·¯ç”±è½¬å‘    â”‚  è®¤è¯æˆæƒ   â”‚  é™æµç†”æ–­   â”‚  APIæ–‡æ¡£               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       æ ¸å¿ƒæœåŠ¡å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æµç¨‹æœåŠ¡     â”‚ æ‰§è¡ŒæœåŠ¡    â”‚ AgentæœåŠ¡   â”‚ MCPä»£ç†æœåŠ¡            â”‚
â”‚ Process     â”‚ Execution   â”‚ Agent       â”‚ MCP-Proxy              â”‚
â”‚ Service     â”‚ Service     â”‚ Service     â”‚ Service                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åŸºç¡€è®¾æ–½å±‚                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ äº‹ä»¶æ€»çº¿     â”‚ æ¶ˆæ¯é˜Ÿåˆ—    â”‚ åˆ†å¸ƒå¼ç¼“å­˜  â”‚ æ•°æ®åº“é›†ç¾¤             â”‚
â”‚ Event Bus   â”‚ Message     â”‚ Redis       â”‚ MySQL Cluster          â”‚
â”‚            â”‚ Queue       â”‚ Cluster     â”‚                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å¤–éƒ¨ç³»ç»Ÿå±‚                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AIæ¨¡å‹æœåŠ¡   â”‚ ç¬¬ä¸‰æ–¹å·¥å…·  â”‚ ç›‘æ§ç³»ç»Ÿ    â”‚ æ—¥å¿—ç³»ç»Ÿ               â”‚
â”‚ LLM APIs    â”‚ External    â”‚ Prometheus  â”‚ ELK Stack              â”‚
â”‚            â”‚ Tools       â”‚ Grafana     â”‚                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 é¢†åŸŸæ¨¡å‹è®¾è®¡

#### 2.2.1 æµç¨‹åŸŸ (Process Domain)
```java
// æµç¨‹èšåˆæ ¹
@Entity
@Table(name = "workflow_process")
public class WorkflowProcess {
    @Id
    private ProcessId processId;
    private ProcessName name;
    private ProcessDefinition definition;
    private ProcessVersion version;
    private ProcessStatus status;
    private List<ProcessVariable> variables;
    
    // ä¸šåŠ¡æ–¹æ³•
    public ProcessInstance createInstance(ProcessContext context) {
        return ProcessInstance.create(this, context);
    }
    
    public void updateDefinition(ProcessDefinition newDefinition) {
        this.definition = newDefinition;
        this.version = this.version.increment();
        DomainEventPublisher.publish(new ProcessDefinitionUpdatedEvent(this));
    }
}

// æµç¨‹å®ä¾‹
@Entity
@Table(name = "process_instance")
public class ProcessInstance {
    @Id
    private InstanceId instanceId;
    private ProcessId processId;
    private InstanceStatus status;
    private ExecutionContext context;
    private List<TaskInstance> tasks;
    
    public void start() {
        this.status = InstanceStatus.RUNNING;
        DomainEventPublisher.publish(new ProcessInstanceStartedEvent(this));
    }
    
    public void complete() {
        this.status = InstanceStatus.COMPLETED;
        DomainEventPublisher.publish(new ProcessInstanceCompletedEvent(this));
    }
}
```

#### 2.2.2 æ‰§è¡ŒåŸŸ (Execution Domain)
```java
// ä»»åŠ¡èšåˆæ ¹
@Entity
@Table(name = "task_instance")
public class TaskInstance {
    @Id
    private TaskId taskId;
    private InstanceId instanceId;
    private TaskDefinition definition;
    private TaskStatus status;
    private AgentId assignedAgent;
    private TaskContext context;
    
    public TaskResult execute(Agent agent) {
        this.status = TaskStatus.RUNNING;
        DomainEventPublisher.publish(new TaskStartedEvent(this));
        
        TaskResult result = agent.execute(this.definition, this.context);
        
        this.status = result.isSuccess() ? TaskStatus.COMPLETED : TaskStatus.FAILED;
        DomainEventPublisher.publish(new TaskCompletedEvent(this, result));
        
        return result;
    }
}

// æ‰§è¡Œå¼•æ“
@Component
public class ExecutionEngine {
    
    @EventHandler
    public void handle(ProcessInstanceStartedEvent event) {
        ProcessInstance instance = event.getProcessInstance();
        List<TaskDefinition> initialTasks = instance.getInitialTasks();
        
        for (TaskDefinition taskDef : initialTasks) {
            scheduleTask(TaskInstance.create(instance.getInstanceId(), taskDef));
        }
    }
    
    @EventHandler  
    public void handle(TaskCompletedEvent event) {
        TaskInstance completedTask = event.getTaskInstance();
        List<TaskDefinition> nextTasks = getNextTasks(completedTask);
        
        for (TaskDefinition taskDef : nextTasks) {
            scheduleTask(TaskInstance.create(completedTask.getInstanceId(), taskDef));
        }
    }
    
    private void scheduleTask(TaskInstance task) {
        taskScheduler.schedule(task);
    }
}
```

#### 2.2.3 AgentåŸŸ (Agent Domain)
```java
// Agentèšåˆæ ¹
@Entity
@Table(name = "agent")
public class Agent {
    @Id
    private AgentId agentId;
    private AgentName name;
    private AgentType type;
    private AgentCapabilities capabilities;
    private AgentStatus status;
    private AgentConfiguration configuration;
    
    public boolean canHandle(TaskDefinition task) {
        return capabilities.supports(task.getRequiredCapabilities());
    }
    
    public TaskResult execute(TaskDefinition task, TaskContext context) {
        if (!canHandle(task)) {
            throw new UnsupportedTaskException("Agent cannot handle this task");
        }
        
        DomainEventPublisher.publish(new AgentTaskStartedEvent(this, task));
        
        try {
            TaskResult result = doExecute(task, context);
            DomainEventPublisher.publish(new AgentTaskCompletedEvent(this, task, result));
            return result;
        } catch (Exception e) {
            DomainEventPublisher.publish(new AgentTaskFailedEvent(this, task, e));
            throw e;
        }
    }
    
    protected abstract TaskResult doExecute(TaskDefinition task, TaskContext context);
}

// LLM Agentå®ç°
@Component
public class LLMAgent extends Agent {
    
    private final MCPClient mcpClient;
    
    @Override
    protected TaskResult doExecute(TaskDefinition task, TaskContext context) {
        MCPRequest request = MCPRequestBuilder.build(task, context);
        MCPResponse response = mcpClient.sendRequest(request);
        return TaskResultMapper.map(response);
    }
}
```

### 2.3 äº‹ä»¶é©±åŠ¨æ¶æ„

#### 2.3.1 äº‹ä»¶å®šä¹‰
```java
// åŸºç¡€äº‹ä»¶
public abstract class DomainEvent {
    private final EventId eventId;
    private final Instant occurredOn;
    private final String eventType;
    
    protected DomainEvent(String eventType) {
        this.eventId = EventId.generate();
        this.occurredOn = Instant.now();
        this.eventType = eventType;
    }
}

// æµç¨‹äº‹ä»¶
public class ProcessInstanceStartedEvent extends DomainEvent {
    private final ProcessInstance processInstance;
    
    public ProcessInstanceStartedEvent(ProcessInstance processInstance) {
        super("ProcessInstanceStarted");
        this.processInstance = processInstance;
    }
}

public class TaskCompletedEvent extends DomainEvent {
    private final TaskInstance taskInstance;
    private final TaskResult result;
    
    public TaskCompletedEvent(TaskInstance taskInstance, TaskResult result) {
        super("TaskCompleted");
        this.taskInstance = taskInstance;
        this.result = result;
    }
}
```

#### 2.3.2 äº‹ä»¶å¤„ç†å™¨
```java
@Component
public class ProcessEventHandler {
    
    private final TaskScheduler taskScheduler;
    private final NotificationService notificationService;
    
    @EventHandler
    @Async("eventExecutor")
    public void handle(ProcessInstanceStartedEvent event) {
        log.info("Process instance started: {}", event.getProcessInstance().getInstanceId());
        
        // è°ƒåº¦åˆå§‹ä»»åŠ¡
        List<TaskDefinition> initialTasks = event.getProcessInstance().getInitialTasks();
        initialTasks.forEach(taskScheduler::schedule);
        
        // å‘é€é€šçŸ¥
        notificationService.notifyProcessStarted(event.getProcessInstance());
    }
    
    @EventHandler
    @Async("eventExecutor")
    public void handle(TaskCompletedEvent event) {
        log.info("Task completed: {}", event.getTaskInstance().getTaskId());
        
        // æ›´æ–°æµç¨‹çŠ¶æ€
        processService.updateProgress(event.getTaskInstance().getInstanceId());
        
        // è°ƒåº¦åç»­ä»»åŠ¡
        List<TaskDefinition> nextTasks = processService.getNextTasks(event.getTaskInstance());
        nextTasks.forEach(taskScheduler::schedule);
    }
}
```

### 2.4 å“åº”å¼ç¼–ç¨‹æ¨¡å¼

#### 2.4.1 å“åº”å¼ä»»åŠ¡æ‰§è¡Œå™¨
```java
@Component
public class ReactiveTaskExecutor {
    
    private final AgentSelector agentSelector;
    private final TaskRepository taskRepository;
    
    public Mono<TaskResult> executeTask(TaskId taskId) {
        return taskRepository.findById(taskId)
            .cast(TaskInstance.class)
            .flatMap(this::selectAndExecute)
            .doOnSuccess(result -> publishTaskCompletedEvent(taskId, result))
            .doOnError(error -> publishTaskFailedEvent(taskId, error))
            .onErrorResume(this::handleTaskError);
    }
    
    private Mono<TaskResult> selectAndExecute(TaskInstance task) {
        return agentSelector.selectAgent(task.getDefinition())
            .flatMap(agent -> Mono.fromCallable(() -> agent.execute(task.getDefinition(), task.getContext()))
                .subscribeOn(Schedulers.boundedElastic()));
    }
    
    private Mono<TaskResult> handleTaskError(Throwable error) {
        log.error("Task execution failed", error);
        return Mono.just(TaskResult.failed(error.getMessage()));
    }
}
```

#### 2.4.2 å“åº”å¼Agenté€‰æ‹©å™¨
```java
@Component
public class ReactiveAgentSelector {
    
    private final AgentRepository agentRepository;
    private final LoadBalancer loadBalancer;
    
    public Mono<Agent> selectAgent(TaskDefinition task) {
        return agentRepository.findAvailableAgents(task.getRequiredCapabilities())
            .collectList()
            .filter(agents -> !agents.isEmpty())
            .map(agents -> loadBalancer.select(agents))
            .switchIfEmpty(Mono.error(new NoAvailableAgentException()));
    }
}
```

---

## 3. å¾®æœåŠ¡æ‹†åˆ†

### 3.1 æœåŠ¡æ‹†åˆ†ç­–ç•¥

#### 3.1.1 æµç¨‹æœåŠ¡ (Process Service)
```java
@RestController
@RequestMapping("/api/v1/processes")
public class ProcessController {
    
    private final ProcessService processService;
    
    @PostMapping("/definitions")
    public Mono<ResponseEntity<ProcessDefinitionResponse>> createProcessDefinition(
            @RequestBody @Valid CreateProcessDefinitionRequest request) {
        
        return processService.createProcessDefinition(request)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.badRequest().build());
    }
    
    @PostMapping("/instances")
    public Mono<ResponseEntity<ProcessInstanceResponse>> startProcessInstance(
            @RequestBody @Valid StartProcessInstanceRequest request) {
        
        return processService.startProcessInstance(request)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.badRequest().build());
    }
}

@Service
public class ProcessService {
    
    private final ProcessRepository processRepository;
    private final EventPublisher eventPublisher;
    
    public Mono<ProcessDefinition> createProcessDefinition(CreateProcessDefinitionRequest request) {
        return Mono.fromCallable(() -> {
            ProcessDefinition process = ProcessDefinition.create(
                request.getName(),
                request.getDefinition(),
                request.getVariables()
            );
            return processRepository.save(process);
        })
        .subscribeOn(Schedulers.boundedElastic())
        .doOnSuccess(process -> eventPublisher.publish(new ProcessDefinitionCreatedEvent(process)));
    }
    
    public Mono<ProcessInstance> startProcessInstance(StartProcessInstanceRequest request) {
        return processRepository.findById(request.getProcessId())
            .map(process -> process.createInstance(request.getContext()))
            .flatMap(instance -> Mono.fromCallable(() -> processRepository.save(instance)))
            .doOnSuccess(instance -> eventPublisher.publish(new ProcessInstanceStartedEvent(instance)));
    }
}
```

#### 3.1.2 æ‰§è¡ŒæœåŠ¡ (Execution Service)
```java
@RestController
@RequestMapping("/api/v1/execution")
public class ExecutionController {
    
    private final ExecutionService executionService;
    
    @GetServer(value = "/tasks/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<TaskStatusUpdate> streamTaskUpdates() {
        return executionService.getTaskStatusUpdates();
    }
    
    @PostMapping("/tasks/{taskId}/retry")
    public Mono<ResponseEntity<TaskResult>> retryTask(@PathVariable String taskId) {
        return executionService.retryTask(TaskId.of(taskId))
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}

@Service
public class ExecutionService {
    
    private final TaskExecutor taskExecutor;
    private final TaskRepository taskRepository;
    private final Sinks.Many<TaskStatusUpdate> taskUpdates;
    
    public Flux<TaskStatusUpdate> getTaskStatusUpdates() {
        return taskUpdates.asFlux();
    }
    
    @EventHandler
    public void handle(ProcessInstanceStartedEvent event) {
        ProcessInstance instance = event.getProcessInstance();
        List<TaskDefinition> initialTasks = instance.getInitialTasks();
        
        Flux.fromIterable(initialTasks)
            .flatMap(this::createAndScheduleTask)
            .subscribe();
    }
    
    private Mono<TaskInstance> createAndScheduleTask(TaskDefinition taskDef) {
        return Mono.fromCallable(() -> TaskInstance.create(taskDef))
            .flatMap(task -> taskRepository.save(task))
            .flatMap(task -> taskExecutor.executeAsync(task))
            .doOnNext(this::notifyTaskUpdate);
    }
    
    private void notifyTaskUpdate(TaskInstance task) {
        TaskStatusUpdate update = TaskStatusUpdate.from(task);
        taskUpdates.tryEmitNext(update);
    }
}
```

#### 3.1.3 AgentæœåŠ¡ (Agent Service)
```java
@RestController
@RequestMapping("/api/v1/agents")
public class AgentController {
    
    private final AgentService agentService;
    
    @PostMapping("/register")
    public Mono<ResponseEntity<AgentRegistrationResponse>> registerAgent(
            @RequestBody @Valid AgentRegistrationRequest request) {
        
        return agentService.registerAgent(request)
            .map(ResponseEntity::ok)
            .onErrorResume(AgentRegistrationException.class, 
                e -> Mono.just(ResponseEntity.badRequest().build()));
    }
    
    @GetMapping("/health")
    public Flux<AgentHealthStatus> getAgentHealthStatus() {
        return agentService.getAllAgentHealthStatus();
    }
}

@Service
public class AgentService {
    
    private final AgentRepository agentRepository;
    private final AgentHealthChecker healthChecker;
    
    public Mono<Agent> registerAgent(AgentRegistrationRequest request) {
        return Mono.fromCallable(() -> {
            Agent agent = Agent.create(
                request.getName(),
                request.getType(),
                request.getCapabilities(),
                request.getConfiguration()
            );
            return agentRepository.save(agent);
        })
        .subscribeOn(Schedulers.boundedElastic())
        .doOnSuccess(agent -> startHealthChecking(agent));
    }
    
    public Flux<AgentHealthStatus> getAllAgentHealthStatus() {
        return agentRepository.findAll()
            .flatMap(agent -> healthChecker.checkHealth(agent)
                .map(status -> AgentHealthStatus.of(agent, status)));
    }
    
    @Scheduled(fixedRate = 30000)
    public void performHealthChecks() {
        agentRepository.findAll()
            .flatMap(this::checkAndUpdateHealth)
            .subscribe();
    }
    
    private Mono<Agent> checkAndUpdateHealth(Agent agent) {
        return healthChecker.checkHealth(agent)
            .flatMap(status -> {
                agent.updateHealthStatus(status);
                return agentRepository.save(agent);
            });
    }
}
```

### 3.2 MCPä»£ç†æœåŠ¡

#### 3.2.1 MCPå®¢æˆ·ç«¯
```java
@Component
public class MCPClient {
    
    private final WebClient webClient;
    private final MCPConnectionManager connectionManager;
    private final CircuitBreaker circuitBreaker;
    
    public Mono<MCPResponse> sendRequest(MCPRequest request) {
        return connectionManager.getConnection(request.getModelProvider())
            .flatMap(connection -> sendRequestWithConnection(request, connection))
            .transform(circuitBreaker::executeSupplier)
            .retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
            .timeout(Duration.ofSeconds(30));
    }
    
    private Mono<MCPResponse> sendRequestWithConnection(MCPRequest request, MCPConnection connection) {
        return webClient.post()
            .uri(connection.getEndpoint())
            .headers(headers -> setAuthHeaders(headers, connection))
            .bodyValue(request)
            .retrieve()
            .bodyToMono(MCPResponse.class)
            .doOnSuccess(response -> recordMetrics(request, response))
            .doOnError(error -> recordError(request, error));
    }
}
```

#### 3.2.2 MCPè¿æ¥ç®¡ç†å™¨
```java
@Component
public class MCPConnectionManager {
    
    private final MCPConnectionRepository connectionRepository;
    private final LoadingCache<String, MCPConnection> connectionCache;
    
    public Mono<MCPConnection> getConnection(String modelProvider) {
        return Mono.fromCallable(() -> connectionCache.get(modelProvider))
            .onErrorResume(this::loadConnection);
    }
    
    private Mono<MCPConnection> loadConnection(Throwable error) {
        return connectionRepository.findActiveByProvider(modelProvider)
            .switchIfEmpty(Mono.error(new NoActiveConnectionException(modelProvider)));
    }
    
    @EventHandler
    public void handle(MCPConnectionUpdatedEvent event) {
        connectionCache.invalidate(event.getConnection().getProvider());
    }
}
```

---

## 4. éƒ¨ç½²å’Œè¿ç»´

### 4.1 Kuberneteséƒ¨ç½²é…ç½®

#### 4.1.1 æµç¨‹æœåŠ¡éƒ¨ç½²
```yaml
# process-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: process-service
  labels:
    app: process-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: process-service
  template:
    metadata:
      labels:
        app: process-service
    spec:
      containers:
      - name: process-service
        image: ai-workflow/process-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "kubernetes"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: process-service
spec:
  selector:
    app: process-service
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

#### 4.1.2 é…ç½®ç®¡ç†
```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: ai-workflow-config
data:
  application.yml: |
    spring:
      application:
        name: ai-workflow
      r2dbc:
        url: r2dbc:mysql://${DATABASE_HOST:localhost}:${DATABASE_PORT:3306}/${DATABASE_NAME:ai_workflow}
        username: ${DATABASE_USERNAME:root}
        password: ${DATABASE_PASSWORD:password}
      redis:
        url: redis://${REDIS_HOST:localhost}:${REDIS_PORT:6379}
      kafka:
        bootstrap-servers: ${KAFKA_SERVERS:localhost:9092}
    
    management:
      endpoints:
        web:
          exposure:
            include: health,info,metrics,prometheus
      endpoint:
        health:
          show-details: always
      metrics:
        export:
          prometheus:
            enabled: true
    
    logging:
      pattern:
        console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
      level:
        com.aiworkflow: DEBUG
        org.springframework.r2dbc: DEBUG
```

### 4.2 ç›‘æ§å’Œå¯è§‚æµ‹æ€§

#### 4.2.1 Prometheusç›‘æ§é…ç½®
```yaml
# prometheus-config.yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'ai-workflow-services'
    kubernetes_sd_configs:
    - role: pod
    relabel_configs:
    - source_labels: [__meta_kubernetes_pod_label_app]
      regex: '(process-service|execution-service|agent-service|mcp-proxy-service)'
      action: keep
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
      action: keep
      regex: true
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
      action: replace
      target_label: __metrics_path__
      regex: (.+)
```

#### 4.2.2 Grafanaä»ªè¡¨æ¿
```json
{
  "dashboard": {
    "title": "AI Workflow Monitoring",
    "panels": [
      {
        "title": "Active Process Instances",
        "type": "stat",
        "targets": [
          {
            "expr": "sum(process_instances_active)"
          }
        ]
      },
      {
        "title": "Task Execution Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(task_executions_total[5m])"
          }
        ]
      },
      {
        "title": "Agent Response Time",
        "type": "heatmap", 
        "targets": [
          {
            "expr": "histogram_quantile(0.95, agent_response_time_seconds)"
          }
        ]
      }
    ]
  }
}
```

---

## 5. å¼€å‘æŒ‡å—

### 5.1 æœ¬åœ°å¼€å‘ç¯å¢ƒ

#### 5.1.1 Docker Composeé…ç½®
```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root123
      MYSQL_DATABASE: ai_workflow_dev
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    ports:
      - "9092:9092"
    depends_on:
      - zookeeper

  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

volumes:
  mysql_data:
  redis_data:
```

### 5.2 ä»£ç è§„èŒƒ

#### 5.2.1 åŒ…ç»“æ„è§„èŒƒ
```
com.aiworkflow
â”œâ”€â”€ domain/                    # é¢†åŸŸå±‚
â”‚   â”œâ”€â”€ process/              # æµç¨‹åŸŸ
â”‚   â”œâ”€â”€ execution/            # æ‰§è¡ŒåŸŸ
â”‚   â”œâ”€â”€ agent/                # AgentåŸŸ
â”‚   â””â”€â”€ shared/               # å…±äº«å€¼å¯¹è±¡
â”œâ”€â”€ application/              # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ service/              # åº”ç”¨æœåŠ¡
â”‚   â”œâ”€â”€ handler/              # äº‹ä»¶å¤„ç†å™¨
â”‚   â””â”€â”€ dto/                  # æ•°æ®ä¼ è¾“å¯¹è±¡
â”œâ”€â”€ infrastructure/           # åŸºç¡€è®¾æ–½å±‚
â”‚   â”œâ”€â”€ repository/           # ä»“å‚¨å®ç°
â”‚   â”œâ”€â”€ mcp/                  # MCPå®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ event/                # äº‹ä»¶å‘å¸ƒå™¨
â”‚   â””â”€â”€ config/               # é…ç½®ç±»
â””â”€â”€ interfaces/               # æ¥å£å±‚
    â”œâ”€â”€ rest/                 # RESTæ§åˆ¶å™¨
    â”œâ”€â”€ graphql/              # GraphQLè§£æå™¨
    â””â”€â”€ websocket/            # WebSocketå¤„ç†å™¨
```

---

## 6. æ€»ç»“

### 6.1 é‡æ–°è®¾è®¡çš„æ ¸å¿ƒä¼˜åŠ¿

1. **é¢†åŸŸé©±åŠ¨è®¾è®¡** - æ¸…æ™°çš„ä¸šåŠ¡è¾¹ç•Œå’Œæ›´å¥½çš„å¯ç»´æŠ¤æ€§
2. **äº‹ä»¶é©±åŠ¨æ¶æ„** - æ¾è€¦åˆçš„ç»„ä»¶é€šä¿¡å’Œæ›´å¥½çš„æ‰©å±•æ€§
3. **å“åº”å¼ç¼–ç¨‹** - é«˜å¹¶å‘å¤„ç†èƒ½åŠ›å’Œæ›´å¥½çš„èµ„æºåˆ©ç”¨ç‡
4. **å¾®æœåŠ¡æ¶æ„** - ç‹¬ç«‹éƒ¨ç½²å’Œæ›´å¥½çš„å®¹é”™èƒ½åŠ›
5. **äº‘åŸç”Ÿè®¾è®¡** - æ›´å¥½çš„å¯è§‚æµ‹æ€§å’Œè¿ç»´å‹å¥½

### 6.2 æŠ€æœ¯é€‰å‹ä¼˜åŒ–

- **æ•°æ®åº“**: MySQL â†’ MySQL + R2DBC (å“åº”å¼)
- **ç¼“å­˜**: Redis â†’ Redis Cluster
- **æ¶ˆæ¯é˜Ÿåˆ—**: Redis Stream â†’ Apache Kafka
- **ç¼–ç¨‹æ¨¡å‹**: åŒæ­¥ â†’ å“åº”å¼
- **æ¶æ„æ¨¡å¼**: å•ä½“ â†’ å¾®æœåŠ¡

### 6.3 ä¸‹ä¸€æ­¥å®æ–½è®¡åˆ’

1. **ç¬¬ä¸€é˜¶æ®µ**: æ­å»ºåŸºç¡€æ¶æ„å’Œæ ¸å¿ƒåŸŸæ¨¡å‹
2. **ç¬¬äºŒé˜¶æ®µ**: å®ç°å“åº”å¼ä»»åŠ¡æ‰§è¡Œå¼•æ“
3. **ç¬¬ä¸‰é˜¶æ®µ**: å®Œå–„ç›‘æ§å’Œè¿ç»´ä½“ç³»
4. **ç¬¬å››é˜¶æ®µ**: æ€§èƒ½ä¼˜åŒ–å’Œå‹åŠ›æµ‹è¯•

è¿™ä¸ªé‡æ–°è®¾è®¡çš„æ¶æ„å°†ä¸ºæ‚¨æä¾›ä¸€ä¸ªæ›´ç°ä»£åŒ–ã€å¯æ‰©å±•ã€é«˜æ€§èƒ½çš„AIå·¥ä½œæµç¼–æ’ç³»ç»Ÿã€‚